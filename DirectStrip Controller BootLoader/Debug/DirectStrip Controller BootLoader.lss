
AVRASM ver. 2.1.51  C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader.asm Thu Jul 17 14:14:01 2014

[builtin](2): Including file 'C:\Program Files (x86)\Atmel\Atmel Studio 6.0\extensions\Atmel\AVRAssembler\2.1.51.46\AvrAssembler/Include\m1284pdef.inc'
C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader.asm(13): Including file 'C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\Definitions.inc'
C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader.asm(14): Including file 'C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\macros.inc'
C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader.asm(15): Including file 'C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\fastload.inc'
C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\fastload.inc(174): Including file 'C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\password.inc'
C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\fastload.inc(181): Including file 'C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\command.inc'
C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\command.inc(133): Including file 'C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\message.inc'
C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\command.inc(136): Including file 'C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\verify.inc'
C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\command.inc(139): Including file 'C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\readflash.inc'
C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\command.inc(140): Including file 'C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\progmega.inc'
C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\fastload.inc(182): Including file 'C:\Users\Tom\Documents\GitHub\DirectStrip Controller BootLoader\DirectStrip Controller BootLoader\ft245.inc'
                 
                 ;*************************************************************************
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega1284P.xml *********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m1284Pdef.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega1284P
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega1284P
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M1284PDEF_INC_
                 #define _M1284PDEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega1284P
                 #pragma AVRPART ADMIN PART_NAME ATmega1284P
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x97
                 .equ	SIGNATURE_002	= 0x05
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UDR1	= 0xce	; MEMORY MAPPED
                 .equ	UBRR1L	= 0xcc	; MEMORY MAPPED
                 .equ	UBRR1H	= 0xcd	; MEMORY MAPPED
                 .equ	UCSR1C	= 0xca	; MEMORY MAPPED
                 .equ	UCSR1B	= 0xc9	; MEMORY MAPPED
                 .equ	UCSR1A	= 0xc8	; MEMORY MAPPED
                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                 .equ	OCR3BL	= 0x9a	; MEMORY MAPPED
                 .equ	OCR3BH	= 0x9b	; MEMORY MAPPED
                 .equ	OCR3AL	= 0x98	; MEMORY MAPPED
                 .equ	OCR3AH	= 0x99	; MEMORY MAPPED
                 .equ	ICR3L	= 0x96	; MEMORY MAPPED
                 .equ	ICR3H	= 0x97	; MEMORY MAPPED
                 .equ	TCNT3L	= 0x94	; MEMORY MAPPED
                 .equ	TCNT3H	= 0x95	; MEMORY MAPPED
                 .equ	TCCR3C	= 0x92	; MEMORY MAPPED
                 .equ	TCCR3B	= 0x91	; MEMORY MAPPED
                 .equ	TCCR3A	= 0x90	; MEMORY MAPPED
                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                 .equ	PCMSK3	= 0x73	; MEMORY MAPPED
                 .equ	TIMSK3	= 0x71	; MEMORY MAPPED
                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                 .equ	PRR1	= 0x65	; MEMORY MAPPED
                 .equ	PRR0	= 0x64	; MEMORY MAPPED
                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	RAMPZ	= 0x3b
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	SMCR	= 0x33
                 .equ	OCDR	= 0x31
                 .equ	ACSR	= 0x30
                 .equ	SPDR	= 0x2e
                 .equ	SPSR	= 0x2d
                 .equ	SPCR	= 0x2c
                 .equ	GPIOR2	= 0x2b
                 .equ	GPIOR1	= 0x2a
                 .equ	OCR0B	= 0x28
                 .equ	OCR0A	= 0x27
                 .equ	TCNT0	= 0x26
                 .equ	TCCR0B	= 0x25
                 .equ	TCCR0A	= 0x24
                 .equ	GTCCR	= 0x23
                 .equ	EEARH	= 0x22
                 .equ	EEARL	= 0x21
                 .equ	EEDR	= 0x20
                 .equ	EECR	= 0x1f
                 .equ	GPIOR0	= 0x1e
                 .equ	EIMSK	= 0x1d
                 .equ	EIFR	= 0x1c
                 .equ	PCIFR	= 0x1b
                 .equ	TIFR3	= 0x18
                 .equ	TIFR2	= 0x17
                 .equ	TIFR1	= 0x16
                 .equ	TIFR0	= 0x15
                 .equ	PORTD	= 0x0b
                 .equ	DDRD	= 0x0a
                 .equ	PIND	= 0x09
                 .equ	PORTC	= 0x08
                 .equ	DDRC	= 0x07
                 .equ	PINC	= 0x06
                 .equ	PORTB	= 0x05
                 .equ	DDRB	= 0x04
                 .equ	PINB	= 0x03
                 .equ	PORTA	= 0x02
                 .equ	DDRA	= 0x01
                 .equ	PINA	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCPHA0	= UCSZ00	; For compatibility
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	UDORD0	= UCSZ01	; For compatibility
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL00	= 6	; USART Mode Select
                 .equ	UMSEL0	= UMSEL00	; For compatibility
                 .equ	UMSEL01	= 7	; USART Mode Select
                 .equ	UMSEL1	= UMSEL01	; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** PORTA ************************
                 ; PORTA - Port A Data Register
                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                 .equ	PA0	= 0	; For compatibility
                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                 .equ	PA1	= 1	; For compatibility
                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                 .equ	PA2	= 2	; For compatibility
                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                 .equ	PA3	= 3	; For compatibility
                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                 .equ	PA4	= 4	; For compatibility
                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                 .equ	PA5	= 5	; For compatibility
                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                 .equ	PA6	= 6	; For compatibility
                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                 .equ	PA7	= 7	; For compatibility
                 
                 ; DDRA - Port A Data Direction Register
                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                 
                 ; PINA - Port A Input Pins
                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                 .equ	PC7	= 7	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCR0A_0	= 0	; 
                 .equ	OCR0A_1	= 1	; 
                 .equ	OCR0A_2	= 2	; 
                 .equ	OCR0A_3	= 3	; 
                 .equ	OCR0A_4	= 4	; 
                 .equ	OCR0A_5	= 5	; 
                 .equ	OCR0A_6	= 6	; 
                 .equ	OCR0A_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PSR10	= PSRSYNC	; For compatibility
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
                 .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                 .equ	OCF1A	= 1	; Timer/Counter1 Output Compare A Match Flag
                 .equ	OCF1B	= 2	; Timer/Counter1 Output Compare B Match Flag
                 .equ	ICF1	= 5	; Timer/Counter1 Input Capture Flag
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Pulse Width Modulator Select Bit 0
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Pulse Width Modulator Select Bit 1
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	COM1B0	= 4	; Comparet Ouput Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Clock Select bit 0
                 .equ	CS11	= 1	; Clock Select 1 bit 1
                 .equ	CS12	= 2	; Clock Select1 bit 2
                 .equ	WGM12	= 3	; Waveform Generation Mode Bit 2
                 .equ	CTC1	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode Bit 3
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ	FOC1B	= 6	; Force Output Compare for Channel B
                 .equ	FOC1A	= 7	; Force Output Compare for Channel A
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	TOIE2A	= TOIE2	; For compatibility
                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ	WGM20	= 0	; Waveform Genration Mode
                 .equ	WGM21	= 1	; Waveform Genration Mode
                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM22	= 3	; Waveform Generation Mode
                 .equ	FOC2B	= 6	; Force Output Compare B
                 .equ	FOC2A	= 7	; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                 .equ	EXCLK	= 6	; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PSR2	= PSRASY	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_3 **************
                 ; TIMSK3 - Timer/Counter3 Interrupt Mask Register
                 .equ	TOIE3	= 0	; Timer/Counter3 Overflow Interrupt Enable
                 .equ	OCIE3A	= 1	; Timer/Counter3 Output Compare A Match Interrupt Enable
                 .equ	OCIE3B	= 2	; Timer/Counter3 Output Compare B Match Interrupt Enable
                 .equ	ICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                 
                 ; TIFR3 - Timer/Counter Interrupt Flag register
                 .equ	TOV3	= 0	; Timer/Counter3 Overflow Flag
                 .equ	OCF3A	= 1	; Timer/Counter3 Output Compare A Match Flag
                 .equ	OCF3B	= 2	; Timer/Counter3 Output Compare B Match Flag
                 .equ	ICF3	= 5	; Timer/Counter3 Input Capture Flag
                 
                 ; TCCR3A - Timer/Counter3 Control Register A
                 .equ	WGM30	= 0	; Pulse Width Modulator Select Bit 0
                 .equ	WGM31	= 1	; Pulse Width Modulator Select Bit 1
                 .equ	COM3B0	= 4	; Comparet Ouput Mode 3B, bit 0
                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                 
                 ; TCCR3B - Timer/Counter3 Control Register B
                 .equ	CS30	= 0	; Clock Select bit 0
                 .equ	CS31	= 1	; Clock Select 3 bit 1
                 .equ	CS32	= 2	; Clock Select3 bit 2
                 .equ	WGM32	= 3	; Waveform Generation Mode Bit 2
                 .equ	WGM33	= 4	; Waveform Generation Mode Bit 3
                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                 
                 ; TCCR3C - Timer/Counter3 Control Register C
                 .equ	FOC3B	= 6	; Force Output Compare for Channel B
                 .equ	FOC3A	= 7	; Force Output Compare for Channel A
                 
                 ; OCR3BH - Timer/Counter3 Output Compare Register B High Byte
                 .equ	OCR3AH0	= 0	; Timer/Counter3 Output Compare Register High Byte bit 0
                 .equ	OCR3AH1	= 1	; Timer/Counter3 Output Compare Register High Byte bit 1
                 .equ	OCR3AH2	= 2	; Timer/Counter3 Output Compare Register High Byte bit 2
                 .equ	OCR3AH3	= 3	; Timer/Counter3 Output Compare Register High Byte bit 3
                 .equ	OCR3AH4	= 4	; Timer/Counter3 Output Compare Register High Byte bit 4
                 .equ	OCR3AH5	= 5	; Timer/Counter3 Output Compare Register High Byte bit 5
                 .equ	OCR3AH6	= 6	; Timer/Counter3 Output Compare Register High Byte bit 6
                 .equ	OCR3AH7	= 7	; Timer/Counter3 Output Compare Register High Byte bit 7
                 
                 ; OCR3BL - Timer/Counter3 Output Compare Register B Low Byte
                 .equ	OCR3AL0	= 0	; Timer/Counter3 Output Compare Register Low Byte Bit 0
                 .equ	OCR3AL1	= 1	; Timer/Counter3 Output Compare Register Low Byte Bit 1
                 .equ	OCR3AL2	= 2	; Timer/Counter3 Output Compare Register Low Byte Bit 2
                 .equ	OCR3AL3	= 3	; Timer/Counter3 Output Compare Register Low Byte Bit 3
                 .equ	OCR3AL4	= 4	; Timer/Counter3 Output Compare Register Low Byte Bit 4
                 .equ	OCR3AL5	= 5	; Timer/Counter3 Output Compare Register Low Byte Bit 5
                 .equ	OCR3AL6	= 6	; Timer/Counter3 Output Compare Register Low Byte Bit 6
                 .equ	OCR3AL7	= 7	; Timer/Counter3 Output Compare Register Low Byte Bit 7
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCSR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read While Write section read enable
                 .equ	SIGRD	= 5	; Signature Row Read
                 .equ	RWWSB	= 6	; Read While Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register A
                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 .equ	INTF2	= 2	; External Interrupt Flag 2
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                 .equ	PCIE3	= 3	; Pin Change Interrupt Enable 3
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                 .equ	PCIF3	= 3	; Pin Change Interrupt Flag 3
                 
                 ; PCMSK3 - Pin Change Mask Register 3
                 .equ	PCINT24	= 0	; Pin Change Enable Mask 24
                 .equ	PCINT25	= 1	; Pin Change Enable Mask 25
                 .equ	PCINT26	= 2	; Pin Change Enable Mask 26
                 .equ	PCINT27	= 3	; Pin Change Enable Mask 27
                 .equ	PCINT28	= 4	; Pin Change Enable Mask 28
                 .equ	PCINT29	= 5	; Pin Change Enable Mask 29
                 .equ	PCINT30	= 6	; Pin Change Enable Mask 30
                 .equ	PCINT31	= 7	; Pin Change Enable Mask 31
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 ;.equ	ACME	= 6	; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ	ADC0D	= 0	; 
                 .equ	ADC1D	= 1	; 
                 .equ	ADC2D	= 2	; 
                 .equ	ADC3D	= 3	; 
                 .equ	ADC4D	= 4	; 
                 .equ	ADC5D	= 5	; 
                 .equ	ADC6D	= 6	; 
                 .equ	ADC7D	= 7	; 
                 
                 
                 ; ***** JTAG *************************
                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                 .equ	IDRD	= OCDR7	; For compatibility
                 
                 ; MCUCR - MCU Control Register
                 .equ	JTD	= 7	; JTAG Interface Disable
                 
                 ; MCUSR - MCU Status Register
                 .equ	JTRF	= 4	; JTAG Reset Flag
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARH - EEPROM Address Register Low Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                 .equ	EEAR10	= 2	; EEPROM Read/Write Access Bit 10
                 .equ	EEAR11	= 3	; EEPROM Read/Write Access Bit 11
                 
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ	TWAM0	= 1	; 
                 .equ	TWAMR0	= TWAM0	; For compatibility
                 .equ	TWAM1	= 2	; 
                 .equ	TWAMR1	= TWAM1	; For compatibility
                 .equ	TWAM2	= 3	; 
                 .equ	TWAMR2	= TWAM2	; For compatibility
                 .equ	TWAM3	= 4	; 
                 .equ	TWAMR3	= TWAM3	; For compatibility
                 .equ	TWAM4	= 5	; 
                 .equ	TWAMR4	= TWAM4	; For compatibility
                 .equ	TWAM5	= 6	; 
                 .equ	TWAMR5	= TWAM5	; For compatibility
                 .equ	TWAM6	= 7	; 
                 .equ	TWAMR6	= TWAM6	; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** USART1 ***********************
                 ; UDR1 - USART I/O Data Register
                 .equ	UDR1_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR1_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR1_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR1_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR1_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR1_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR1_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR1A - USART Control and Status Register A
                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                 .equ	U2X1	= 1	; Double the USART transmission speed
                 .equ	UPE1	= 2	; Parity Error
                 .equ	DOR1	= 3	; Data overRun
                 .equ	FE1	= 4	; Framing Error
                 .equ	UDRE1	= 5	; USART Data Register Empty
                 .equ	TXC1	= 6	; USART Transmitt Complete
                 .equ	RXC1	= 7	; USART Receive Complete
                 
                 ; UCSR1B - USART Control and Status Register B
                 .equ	TXB81	= 0	; Transmit Data Bit 8
                 .equ	RXB81	= 1	; Receive Data Bit 8
                 .equ	UCSZ12	= 2	; Character Size
                 .equ	TXEN1	= 3	; Transmitter Enable
                 .equ	RXEN1	= 4	; Receiver Enable
                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR1C - USART Control and Status Register C
                 .equ	UCPOL1	= 0	; Clock Polarity
                 .equ	UCSZ10	= 1	; Character Size
                 .equ	UCPHA1	= UCSZ10	; For compatibility
                 .equ	UCSZ11	= 2	; Character Size
                 .equ	UDORD1	= UCSZ11	; For compatibility
                 .equ	USBS1	= 3	; Stop Bit Select
                 .equ	UPM10	= 4	; Parity Mode Bit 0
                 .equ	UPM11	= 5	; Parity Mode Bit 1
                 .equ	UMSEL10	= 6	; USART Mode Select
                 .equ	UMSEL11	= 7	; USART Mode Select
                 
                 ; UBRR1H - USART Baud Rate Register High Byte
                 .equ	UBRR_8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR_9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR_10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR_11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR1L - USART Baud Rate Register Low Byte
                 .equ	UBRR_0	= 0	; USART Baud Rate Register bit 0
                 .equ	UBRR_1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR_2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR_3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR_4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR_5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR_6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR_7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	PUD	= 4	; Pull-up disable
                 .equ	BODSE	= 5	; BOD Power Down in Sleep Enable
                 .equ	BODS	= 6	; BOD Power Down in Sleep
                 ;.equ	JTD	= 7	; JTAG Interface Disable
                 
                 ; MCUSR - MCU Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - 
                 .equ	CLKPS0	= 0	; 
                 .equ	CLKPS1	= 1	; 
                 .equ	CLKPS2	= 2	; 
                 .equ	CLKPS3	= 3	; 
                 .equ	CLKPCE	= 7	; 
                 
                 ; SMCR - Sleep Mode Control Register
                 .equ	SE	= 0	; Sleep Enable
                 .equ	SM0	= 1	; Sleep Mode Select bit 0
                 .equ	SM1	= 2	; Sleep Mode Select bit 1
                 .equ	SM2	= 3	; Sleep Mode Select bit 2
                 
                 ; RAMPZ - RAM Page Z Select Register
                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                 
                 ; GPIOR2 - General Purpose IO Register 2
                 .equ	GPIOR20	= 0	; General Purpose IO Register 2 bit 0
                 .equ	GPIOR21	= 1	; General Purpose IO Register 2 bit 1
                 .equ	GPIOR22	= 2	; General Purpose IO Register 2 bit 2
                 .equ	GPIOR23	= 3	; General Purpose IO Register 2 bit 3
                 .equ	GPIOR24	= 4	; General Purpose IO Register 2 bit 4
                 .equ	GPIOR25	= 5	; General Purpose IO Register 2 bit 5
                 .equ	GPIOR26	= 6	; General Purpose IO Register 2 bit 6
                 .equ	GPIOR27	= 7	; General Purpose IO Register 2 bit 7
                 
                 ; GPIOR1 - General Purpose IO Register 1
                 .equ	GPIOR10	= 0	; General Purpose IO Register 1 bit 0
                 .equ	GPIOR11	= 1	; General Purpose IO Register 1 bit 1
                 .equ	GPIOR12	= 2	; General Purpose IO Register 1 bit 2
                 .equ	GPIOR13	= 3	; General Purpose IO Register 1 bit 3
                 .equ	GPIOR14	= 4	; General Purpose IO Register 1 bit 4
                 .equ	GPIOR15	= 5	; General Purpose IO Register 1 bit 5
                 .equ	GPIOR16	= 6	; General Purpose IO Register 1 bit 6
                 .equ	GPIOR17	= 7	; General Purpose IO Register 1 bit 7
                 
                 ; GPIOR0 - General Purpose IO Register 0
                 .equ	GPIOR00	= 0	; General Purpose IO Register 0 bit 0
                 .equ	GPIOR01	= 1	; General Purpose IO Register 0 bit 1
                 .equ	GPIOR02	= 2	; General Purpose IO Register 0 bit 2
                 .equ	GPIOR03	= 3	; General Purpose IO Register 0 bit 3
                 .equ	GPIOR04	= 4	; General Purpose IO Register 0 bit 4
                 .equ	GPIOR05	= 5	; General Purpose IO Register 0 bit 5
                 .equ	GPIOR06	= 6	; General Purpose IO Register 0 bit 6
                 .equ	GPIOR07	= 7	; General Purpose IO Register 0 bit 7
                 
                 ; PRR0 - Power Reduction Register0
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSART0	= 1	; Power Reduction USART 0
                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 .equ	PRUSART1	= 4	; Power Reduction USART 1
                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                 .equ	PRTWI	= 7	; Power Reduction TWI
                 
                 ; PRR1 - Power Reduction Register1
                 .equ	PRTIM3	= 0	; Power Reduction Timer/Counter3
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock output
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	WDTON	= 4	; Watchdog timer always on
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	JTAGEN	= 6	; Enable JTAG
                 .equ	OCDEN	= 7	; Enable OCD
                 
                 ; EXTENDED fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0xffff	; Note: Word address
                 .equ	IOEND	= 0x00ff
                 .equ	SRAM_START	= 0x0100
                 .equ	SRAM_SIZE	= 16384
                 .equ	RAMEND	= 0x40ff
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x0fff
                 .equ	EEPROMEND	= 0x0fff
                 .equ	EEADRBITS	= 12
                 #pragma AVRPART MEMORY PROG_FLASH 131072
                 #pragma AVRPART MEMORY EEPROM 4096
                 #pragma AVRPART MEMORY INT_SRAM SIZE 16384
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0xf000
                 .equ	NRWW_STOP_ADDR	= 0xffff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0xefff
                 .equ	PAGESIZE	= 128
                 .equ	FIRSTBOOTSTART	= 0xfe00
                 .equ	SECONDBOOTSTART	= 0xfc00
                 .equ	THIRDBOOTSTART	= 0xf800
                 .equ	FOURTHBOOTSTART	= 0xf000
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                 .equ	PCI0addr	= 0x0008	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x000a	; Pin Change Interrupt Request 1
                 .equ	PCI2addr	= 0x000c	; Pin Change Interrupt Request 2
                 .equ	PCI3addr	= 0x000e	; Pin Change Interrupt Request 3
                 .equ	WDTaddr	= 0x0010	; Watchdog Time-out Interrupt
                 .equ	OC2Aaddr	= 0x0012	; Timer/Counter2 Compare Match A
                 .equ	OC2Baddr	= 0x0014	; Timer/Counter2 Compare Match B
                 .equ	OVF2addr	= 0x0016	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0018	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x001a	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x001c	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x001e	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x0020	; Timer/Counter0 Compare Match A
                 .equ	OC0Baddr	= 0x0022	; Timer/Counter0 Compare Match B
                 .equ	OVF0addr	= 0x0024	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x0026	; SPI Serial Transfer Complete
                 .equ	URXC0addr	= 0x0028	; USART0, Rx Complete
                 .equ	UDRE0addr	= 0x002a	; USART0 Data register Empty
                 .equ	UTXC0addr	= 0x002c	; USART0, Tx Complete
                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                 .equ	ADCCaddr	= 0x0030	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x0032	; EEPROM Ready
                 .equ	TWIaddr	= 0x0034	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0036	; Store Program Memory Read
                 .equ	URXC1addr	= 0x0038	; USART1 RX complete
                 .equ	UDRE1addr	= 0x003a	; USART1 Data Register Empty
                 .equ	UTXC1addr	= 0x003c	; USART1 TX complete
                 .equ	ICP3addr	= 0x003e	; Timer/Counter3 Capture Event
                 .equ	OC3Aaddr	= 0x0040	; Timer/Counter3 Compare Match A
                 .equ	OC3Baddr	= 0x0042	; Timer/Counter3 Compare Match B
                 .equ	OVF3addr	= 0x0044	; Timer/Counter3 Overflow
                 
                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                 
                 #endif  /* _M1284PDEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                 ;*									 *
                 ;*				Generic AVR Bootloader			 *
                 ;*                                                                       *
                 ;*                      Author: Peter Dannegger                          *
                 ;*									 *
                 ;*************************************************************************
                 .list
                 .listmac
                 
                 
                 ;-------------------------------------------------------------------------
                 .include "Definitions.inc"
                 
                 ;*************************************************************************
                 ;-------------------------------------------------------------------------
                 ;				Constant definitions
                 ;-------------------------------------------------------------------------
                 .equ	VERSION		 = 0x0201
                 
                 //.equ	XTAL		= 20000000	; 8MHz, not critical 
                 //.equ	BootDelay	= XTAL / 3	; 0.33s
                 
                 
                 ;----------------------------- FT245 port defs ---------------------------
                 
                  ;FT245RL
                  ;Use ports with adresses<0x20 for the FT245 to allow for most efficient communication
                  .EQU FT245_DataPort = PORTC
                  .equ FT245_DataPin = PINC
                  .equ FT245_DataDDR = DDRC
                 
                  .equ FT245_StatusPin=PIND
                  .equ FT245_StatusPort=PORTD
                  .equ FT245_StatusDDR=DDRD
                 
                  .equ FT245_TXEBit=7
                  .equ FT245_RXFBit=6
                  .equ FT245_WRBit=4
                  .equ FT245_RDBit=5
                 
                   ;Leds
                  .equ Led_DDR=DDRD
                  .equ Led_Port=PORTD
                  .equ Led_Yellow_Bit=2
                  .equ Led_Red_Bit=3
                 
                 ;------------------------------	select bootloader size -------------------
                 
                 
                 
                 //.equ	BootSize	=   500 ;richtiger wert?
                 //.equ	BootSize	= CRC + VERIFY + ONEWIRE + WDTRIGGER + MinSize	;org version
                 
                 .equ	BootStart	= FirstBootStart   ; = 0xfe00
                 .set	BufferSize	= 512  
                 .equ	UserFlash	= (2*BootStart) ;;==130048 == 0x1fc00
                 .equ	Application	= 0
                 
                 /*;------------------------------	Bootloader fuse setting ------------------
                 .ifdef	FirstBootStart
                   .if	(FlashEnd - FirstBootStart) >= 255	; 256 Words needed
                     .equ	BootStart	= FirstBootStart   ;fr m1284 wird dieser gewhlt = 0xfe00
                   .else
                     .equ	BootStart	= SecondBootStart
                   .endif
                   ;----------------------------	max possible buffer size -----------------
                   .set	BufferSize	= SRAM_SIZE / 2 - PAGESIZE   ;=8064
                 
                   .macro testpage
                     .if		BootStart % BufferSize         ;=512 (true) @ first try
                       .set	BufferSize = BufferSize - PAGESIZE ;=7936 @first try
                       .if	BootStart % BufferSize ;=1536 @first try
                         .set    BufferSize = BufferSize - PAGESIZE 
                         testpage
                       .endif
                     .endif
                   .endmacro
                 	testpage	; calculate Buffersize to fit into BootStart  ==== ergibt 512 fr buffersize
                   ;-----------------------------------------------------------------------
                   .equ	UserFlash	= (2*BootStart)  ;==130048 == 0x1fc00
                   .equ	Application	= 0
                 .else
                   .equ	BootStart	= ((FlashEnd - BootSize) / PageSize * PageSize)
                   .equ	BufferSize	= PageSize
                   .equ	UserFlash	= (2*BootStart - 2)
                   .equ	Application	= BootStart - 1
                 .endif
                 */;-------------------------------------------------------------------------
                 ;				Using register
                 ;-------------------------------------------------------------------------
                 .def	zerol		= r2
                 .def	zeroh		= r3
                 //.def	baudl		= r4		; baud divider
                 //.def	baudh		= r5
                 //.def	crcl		= r6
                 //.def	crch		= r7
                 
                 ;-------------------------------------------------------------------------
                 //.def	appl		= r16		; rjmp to application
                 //.def	apph		= r17
                 .def RL2=r17
                 .def RL1=r16
                 .def RL0=r19
                 .def	RTemp = r20
                 .def RCommandByte=r18
                 .def RData=R4
                 
                 .def	zx		= r21		; 3 byte Z pointer
                 .def	a0		= r22		; working registers
                 .def	a1		= r23
                 .def	RLoopCounterL		= r24		;Loopcounter low
                 .def	RLoopCounterH		= r25       ;Loopcounterhigh
                 ;-------------------------------------------------------------------------
                 ;				Using SRAM
                 ;-------------------------------------------------------------------------
                 .dseg
                 	.org		SRAM_START
000100           PROGBUFF:		.byte 2*BufferSize
                 PROGBUFFEND:
                 .cseg
                 
                 
                 ;-------------------------------------------------------------------------
                 
                 ;------------------------------------------------------------------------
                 ;			redefinitions for compatibility
                 ;------------------------------------------------------------------------
                 .ifndef	WDTCSR
                 .endif
                 ;---------------------------
                 .ifndef	WDCE
                 .endif
                 ;---------------------------
                 .ifndef	SPMCSR
                 .endif
                 ;---------------------------
                 .ifndef	RWWSRE
                 .ifdef  ASRE
                 .endif
                 .endif
                 ;---------------------------
                 .ifndef SPMEN
                 .endif
                 
                 ;------------------------------------------------------------------------
                 //*************************************************************************
                 //				Protocol definitions
                 //-------------------------------------------------------------------------
                 .equ	COMMAND		= 'C'		// Command sequence start
                 .equ ESCAPE	=	COMMAND
                 
                 
                 
                 .equ	CONTINUE	= 0xA9
                 
                 
                 
                 .equ	ESC_SHIFT	= 0x80		// offset escape char
                 .include "macros.inc"
                 
                 ;				Macros
                 ;-------------------------------------------------------------------------
                 
                 
                 
                 
                 
                 
                 .macro FT245_SetInput
                   //WritePortValue FT245_DataPort,0x00
                   WritePortValue FT245_DataDDR,0x00
                 .endm
                 
                 .macro FT245_SetOutput
                   WritePortValue FT245_DataDDR,0xff
                 .endm
                 
                 .macro FT245_WaitForRead
                   FT245_WaitForReadLoop:
                          sbic FT245_StatusPin, FT245_RxfBit
                 	 rjmp FT245_WaitForReadLoop
                 .endm
                 
                 
                 .macro FT245_ReadByte  ;(Register) 
                 
                 	 cbi FT245_StatusPort, FT245_RdBit
                 	 nop
                      nop
                 	 nop
                 	 nop
                 	 in @0, FT245_DataPin
                 	 sbi FT245_StatusPort, FT245_RdBit
                 .endm
                 
                 
                 
                 .macro FT245_WaitForWrite
                   FT245_WaitForWriteLoop:
                          sbic FT245_StatusPin, FT245_TxeBit
                 	 rjmp FT245_WaitForWriteLoop
                 .endm
                 
                 
                 .macro FT245_WriteByte;(Register)
                 
                      nop
                 	 nop
                 	 sbi FT245_StatusPort, FT245_WrBit
                 	 nop
                 	 nop
                 	 nop
                 	 out FT245_DataPort,@0
                 	 nop
                 	 nop
                 	 nop
                 	 cbi FT245_StatusPort, FT245_WrBit
                 .endm
                 
                 
                 .macro FT245_SendByte;(Register)
                   FT245_WaitForWrite
                   FT245_SetOutput
                   FT245_WriteByte @0
                   FT245_SetInput
                 .endm
                 
                 .macro FT245_SendAck
                   FT245_WaitForWrite
                   FT245_SetOutput
                   ldi RTemp,'A'
                   FT245_WriteByte RTemp
                   FT245_SetInput
                 .endm
                 
                 .macro FT245_SendNAck
                   FT245_WaitForWrite
                   FT245_SetOutput
                   ldi RTemp,'N'
                   FT245_WriteByte RTemp
                   FT245_SetInput
                 .endm
                 
                 .macro ReadPort  ;(Port, Register) 
                   .if @0 < 0x40
                 	in	@1, @0
                   .else
                   	lds	@1, @0
                   .endif
                 .endm
                 
                 .macro WritePort   ;(Port, Register)
                   .if @0 < 0x40
                 	out	@0, @1
                   .else
                   	sts	@0, @1
                   .endif
                 .endm
                 
                 
                 .macro WritePortValue ;(Port,Value)
                   ldi Rtemp,@1
                   WritePort @0, RTemp
                 .endm
                 
                 .MACRO SetPortBit ;(Port, Bit)
                         .if @0<0x20
                 		  sbi @0,@1
                 		.else
                 		  ReadPort @0,RTemp
                 		  ori RTemp,(1<<@1)
                 		  WritePort @0,RTemp
                 		.endif
                 .ENDMACRO
                 
                 .MACRO ClearPortBit ;(Port, Bit)
                         .if @0<0x20
                 		  cbi @0,@1
                 		.else
                 		  ReadPort @0,RTemp
                 		  andi RTemp,-(1<<@1)
                 		  WritePort @0,RTemp
                 		.endif
                 .ENDMACRO
                 
                 ;----------------------	macros for extended IO access -------------------
                 .macro	xout
                 .if	@0 >  0x3F
                 	sts	@0, @1
                 .else
                 	out	@0, @1
                 .endif
                 .endmacro
                 ;---------------------------
                 .macro	xin
                 .if	@1 > 0x3F
                 	lds	@0, @1
                 .else
                 	in	@0, @1
                 .endif
                 .endmacro
                 ;---------------------------
                 .macro  xlpm
                 .if FLASHEND >  0x7FFF
                 	elpm	@0, @1
                 .else
                 	lpm	@0, @1
                 .endif
                 .endmacro
                 
                  
                 .include "fastload.inc"
                 
                 ;*									 *
                 ;*				AVR universal Bootloader		 *
                 ;*									 *
                 ;*			Author: Peter Dannegger				 *
                 ;*									 *
                 ;*************************************************************************
                 
                 .list
                 	.org	BootStart
                 init:
00fe00 94f8      	cli						; no interrupts allow
                 	
00fe01 95a8      	wdr
                 	;Turn watchdog off
                 ; Clear WDRF in MCUSR
                +
                +  .if MCUSR < 0x40
00fe02 b744     +in RTemp , MCUSR
                +  .else 
                +lds RTemp , MCUSR
                 ReadPort MCUSR, RTemp
00fe03 7040      andi RTemp, (0xff & (0<<WDRF))
                +
                +  .if MCUSR < 0x40
00fe04 bf44     +out MCUSR , RTemp
                +  .else 
                +sts MCUSR , RTemp
                 WritePort MCUSR, RTemp
                 ; Write logical one to WDCE and WDE
                 ; Keep old prescaler setting to prevent unintentional time-out
                +
                +  .if WDTCSR < 0x40
                +in RTemp , WDTCSR
00fe05 9140 0060+  .else 
                +lds RTemp , WDTCSR
                 ReadPort WDTCSR, RTemp 
00fe07 6148      ori RTemp, (1<<WDCE) | (1<<WDE)
                +
                +  .if WDTCSR < 0x40
                +out WDTCSR , RTemp
00fe08 9340 0060+  .else 
                +sts WDTCSR , RTemp
                 WritePort WDTCSR, RTemp
                 ; Turn off WDT
00fe0a e040      ldi RTemp, (0<<WDE)
                +
                +  .if WDTCSR < 0x40
                +out WDTCSR , RTemp
00fe0b 9340 0060+  .else 
                +sts WDTCSR , RTemp
                 WritePort WDTCSR, RTemp
                 ; Turn on global int
                 	
                 	
00fe0d ef6f      	ldi	a0, low (RamEnd)	; initialize stack
00fe0e bf6d      	out	SPL, a0
00fe0f e460      	ldi	a0, high(RamEnd)
00fe10 bf6e      	out	SPH, a0
                 
00fe11 2733      	clr RL0
00fe12 2700      	clr RL1
00fe13 2711      	clr RL2
                 
                 
                 	  ;Set led port bits to output & turn red led on
                +
                +        .if Led_DDR < 0x20
00fe14 9a52     +sbi Led_DDR , Led_Yellow_Bit
                +		.else 
                +ReadPort Led_DDR , RTemp
                   SetPortBit Led_DDR,Led_Yellow_Bit
                +
                +        .if Led_DDR < 0x20
00fe15 9a53     +sbi Led_DDR , Led_Red_Bit
                +		.else 
                +ReadPort Led_DDR , RTemp
                   SetPortBit Led_DDR,Led_Red_Bit
                 
                   ;Turn Red led on
                +
                +        .if Led_Port < 0x20
00fe16 985a     +cbi Led_Port , Led_Yellow_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                   ClearPortBit Led_Port,Led_Yellow_Bit
                +
                +        .if Led_Port < 0x20
00fe17 9a5b     +sbi Led_Port , Led_Red_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                   SetPortBit Led_Port,Led_Red_Bit
                 
                   ;Set IO direction for FT245 data port (input)
                +
                +
                +
00fe18 e040     +ldi Rtemp , 0x00
                +
                +  .if FT245_DataDDR < 0x40
00fe19 b947     +out FT245_DataDDR , RTemp
                +  .else 
                +sts FT245_DataDDR , RTemp
                +WritePort FT245_DataDDR , RTemp
                +WritePortValue FT245_DataDDR , 0x00
                   FT245_SetInput
                 
                   ;Set IO Directtion for FT245 status connectors
                +
                +        .if FT245_StatusDDR < 0x20
00fe1a 9a54     +sbi FT245_StatusDDR , FT245_WRBit
                +		.else 
                +ReadPort FT245_StatusDDR , RTemp
                   SetPortBit FT245_StatusDDR,FT245_WRBit
                +
                +        .if FT245_StatusDDR < 0x20
00fe1b 9a55     +sbi FT245_StatusDDR , FT245_RDBit
                +		.else 
                +ReadPort FT245_StatusDDR , RTemp
                   SetPortBit FT245_StatusDDR,FT245_RDBit
                +
                +        .if FT245_StatusDDR < 0x20
00fe1c 9856     +cbi FT245_StatusDDR , FT245_RxfBit
                +		.else 
                +ReadPort FT245_StatusDDR , RTemp
                   ClearPortBit FT245_StatusDDR,FT245_RxfBit
                +
                +        .if FT245_StatusDDR < 0x20
00fe1d 9857     +cbi FT245_StatusDDR , FT245_TXEBit
                +		.else 
                +ReadPort FT245_StatusDDR , RTemp
                   ClearPortBit FT245_StatusDDR,FT245_TXEBit
                 
                   ;Set Rd and WR to initial values
                +
                +        .if FT245_StatusPort < 0x20
00fe1e 9a5d     +sbi FT245_StatusPort , FT245_RDBit
                +		.else 
                +ReadPort FT245_StatusPort , RTemp
                   SetPortBit FT245_StatusPort,FT245_RDBit
                +
                +        .if FT245_StatusPort < 0x20
00fe1f 9a5c     +sbi FT245_StatusPort , FT245_WRBit
                +		.else 
                +ReadPort FT245_StatusPort , RTemp
                   SetPortBit FT245_StatusPort,FT245_WRBit
                 
                   ;Turn yellow led on
                   //SetPortBit Led_Port,Led_Yellow_Bit
                   //ClearPortBit Led_Port,Led_Red_Bit
                 
                 
                   ; ============================= 
                 ;   Warteschleifen-Generator 
                 ;     60000000 Zyklen:
                 ; ----------------------------- 
                 ; warte 49939965 Zyklen:
00fe20 ef1f                ldi  R17, $FF
00fe21 ef2f      WGLOOP0:  ldi  R18, $FF
00fe22 ef3f      WGLOOP1:  ldi  R19, $FF
00fe23 953a      WGLOOP2:  dec  R19
00fe24 f7f1                brne WGLOOP2
00fe25 952a                dec  R18
00fe26 f7d9                brne WGLOOP1
00fe27 951a                dec  R17
00fe28 f7c1                brne WGLOOP0
                 ; ----------------------------- 
                 ; warte 10060014 Zyklen:
00fe29 e813                ldi  R17, $83
00fe2a e82f      WGLOOP3:  ldi  R18, $8F
00fe2b eb32      WGLOOP4:  ldi  R19, $B2
00fe2c 953a      WGLOOP5:  dec  R19
00fe2d f7f1                brne WGLOOP5
00fe2e 952a                dec  R18
00fe2f f7d9                brne WGLOOP4
00fe30 951a                dec  R17
00fe31 f7c1                brne WGLOOP3
                 
                 ; ============================= 
                   
                 
                 
                   ;Clear FT245 input buffer
00fe32 0000        nop
00fe33 0000        nop
00fe34 994e        sbic FT245_StatusPin, FT245_RxfBit
00fe35 c00c        rjmp FT245_ClearInputBufferExit
                   FT245_ClearInputBufferLoop:
00fe36 985d        cbi FT245_StatusPort, FT245_RdBit
00fe37 0000        nop
00fe38 0000        nop
                 
00fe39 0000        nop
00fe3a 0000        nop
00fe3b 9a5d        sbi FT245_StatusPort, FT245_RdBit
00fe3c 0000        nop
00fe3d 0000        nop
                 
00fe3e 0000        nop
00fe3f 0000        nop
00fe40 9b4e        sbis FT245_StatusPin, FT245_RxfBit
00fe41 cff4        rjmp FT245_ClearInputBufferLoop
                   FT245_ClearInputBufferExit:
                 
                     //SetPortBit Led_Port,Led_Yellow_Bit
                     //ClearPortBit Led_Port,Led_Red_Bit
                 
                 BootLoaderStart:
                 
00fe42 9468      Set
                 waitforfirstchar:
                      	 
00fe43 1730      	cp RL0, RL1
00fe44 f018      	brlo fadeleds_off
                +
                +        .if Led_Port < 0x20
00fe45 9a5b     +sbi Led_Port , Led_Red_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       SetPortBit Led_Port,Led_Red_Bit
                +
                +        .if Led_Port < 0x20
00fe46 9a5a     +sbi Led_Port , Led_Yellow_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       SetPortBit Led_Port,Led_Yellow_Bit
00fe47 c002      	  rjmp fadeleds_cont
                     fadeleds_off:
                +
                +        .if Led_Port < 0x20
00fe48 985b     +cbi Led_Port , Led_Red_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       ClearPortBit Led_Port,Led_Red_Bit
                +
                +        .if Led_Port < 0x20
00fe49 985a     +cbi Led_Port , Led_Yellow_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       ClearPortBit Led_Port,Led_Yellow_Bit
                 	fadeleds_cont:
                 
00fe4a e048      	ldi RTemp,8
00fe4b 0f34      	add RL0,RTemp
00fe4c f419      	brne fadeleds_delaycont
00fe4d 9513      	  inc RL2
00fe4e f409      	  brne fadeleds_delaycont
00fe4f 9503      	    inc RL1
                 	fadeleds_delaycont:
                 	 
                 
                 	  
00fe50 994e               sbic FT245_StatusPin, FT245_RxfBit
00fe51 cff1      	 rjmp waitforfirstchar
                 
                 
                 
                +
                +FT245_WaitForReadLoop :
00fe52 994e     +sbic FT245_StatusPin , FT245_RxfBit
00fe53 cffe     +rjmp FT245_WaitForReadLoop
                      FT245_WaitForRead
00fe54 0000      	 nop
00fe55 0000           nop
                +
                +
00fe56 985d     +cbi FT245_StatusPort , FT245_RdBit
00fe57 0000     +nop
00fe58 0000     +nop
00fe59 0000     +nop
00fe5a 0000     +nop
00fe5b b126     +in RCommandByte , FT245_DataPin
00fe5c 9a5d     +sbi FT245_StatusPort , FT245_RdBit
                      FT245_ReadByte RCommandByte
                 
                 
00fe5d 3020      	 cpi RCommandByte,0
00fe5e f499      	 brne bootloadercontinue1  
                +
                +
                +FT245_WaitForWriteLoop :
00fe5f 994f     +sbic FT245_StatusPin , FT245_TxeBit
00fe60 cffe     +rjmp FT245_WaitForWriteLoop
                +FT245_WaitForWrite
                +
                +
00fe61 ef4f     +ldi Rtemp , 0xff
                +
                +  .if FT245_DataDDR < 0x40
00fe62 b947     +out FT245_DataDDR , RTemp
                +  .else 
                +sts FT245_DataDDR , RTemp
                +WritePort FT245_DataDDR , RTemp
                +WritePortValue FT245_DataDDR , 0xff
                +FT245_SetOutput
00fe63 e44e     +ldi RTemp , 'N'
                +
                +
00fe64 0000     +nop
00fe65 0000     +nop
00fe66 9a5c     +sbi FT245_StatusPort , FT245_WrBit
00fe67 0000     +nop
00fe68 0000     +nop
00fe69 0000     +nop
00fe6a b948     +out FT245_DataPort , RTemp
00fe6b 0000     +nop
00fe6c 0000     +nop
00fe6d 0000     +nop
00fe6e 985c     +cbi FT245_StatusPort , FT245_WrBit
                +FT245_WriteByte RTemp
                +
                +
                +
00fe6f e040     +ldi Rtemp , 0x00
                +
                +  .if FT245_DataDDR < 0x40
00fe70 b947     +out FT245_DataDDR , RTemp
                +  .else 
                +sts FT245_DataDDR , RTemp
                +WritePort FT245_DataDDR , RTemp
                +WritePortValue FT245_DataDDR , 0x00
                +FT245_SetInput
                 	   FT245_SendNack
00fe71 cfd1      	   Rjmp waitforfirstchar
                      bootloadercontinue1:
                 
                 
00fe72 352a      	 cpi RCommandByte,'Z'			;exit bootloader if we have not received Z
00fe73 f009           breq bootloadercontinue
00fe74 c05e      	   rjmp  bootloader_exit
                 	 bootloadercontinue:
00fe75 e560      	 ldi a0,'P'
00fe76 d0dd      	 rcall	putchar
                 	
                 ;-------------------------------------------------------------------------
                 
                 .include "password.inc"			; check password
                 
                 ;				Check password
                 ;-------------------------------------------------------------------------
                 checkpwd:
                 .if FLASHEND > 0x7FFF
00fe77 e061      	ldi	a0, byte3(2*Password)
00fe78 bf6b      	out	RAMPZ, a0
                 .endif
00fe79 edea      	ldi	zl, low (2*Password)
00fe7a effe      	ldi	zh, high(2*Password)
                 checkpwd_nextchar:
                +
                +.if FLASHEND > 0x7FFF
00fe7b 9007     +elpm r0 , z +
                +.else 
                +lpm r0 , z +
                 	XLPM	r0, z+
00fe7c 2000      	tst	r0
00fe7d f0a1      	breq	checkpwd_exit			; end if zero byte
                 	
                 	waitforpwchar:
                      	 
00fe7e 1730      	cp RL0, RL1
00fe7f f018      	brlo waitforpwchar_fadeleds_off
                +
                +        .if Led_Port < 0x20
00fe80 9a5b     +sbi Led_Port , Led_Red_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       SetPortBit Led_Port,Led_Red_Bit
                +
                +        .if Led_Port < 0x20
00fe81 985a     +cbi Led_Port , Led_Yellow_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       ClearPortBit Led_Port,Led_Yellow_Bit
00fe82 c002      	  rjmp waitforpwchar_fadeleds_cont
                     waitforpwchar_fadeleds_off:
                +
                +        .if Led_Port < 0x20
00fe83 985b     +cbi Led_Port , Led_Red_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       ClearPortBit Led_Port,Led_Red_Bit
                +
                +        .if Led_Port < 0x20
00fe84 985a     +cbi Led_Port , Led_Yellow_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       ClearPortBit Led_Port,Led_Yellow_Bit
                 	waitforpwchar_fadeleds_cont:
                 
00fe85 e048      	ldi RTemp,8
00fe86 0f34      	add RL0,RTemp
00fe87 f419      	brne waitforpwchar_fadeleds_delaycont
00fe88 9513      	  inc RL2
00fe89 f409      	  brne waitforpwchar_fadeleds_delaycont
00fe8a 9503      	    inc RL1
                 	waitforpwchar_fadeleds_delaycont:
                 	 
                 
                 	  
00fe8b 994e               sbic FT245_StatusPin, FT245_RxfBit
00fe8c cff1      	 rjmp waitforpwchar
                 	
00fe8d d0bb      	rcall	getchar
00fe8e 1606      	cp	r0, a0
00fe8f f359      	breq	checkpwd_nextchar			; compare next byte
00fe90 d0d9      	    rcall putnack
00fe91 cfb0      	rjmp	BootLoaderStart
                 checkpwd_exit:
                 ;-------------------------------------------------------------------------
                 ;-------------------------------------------------------------------------
                 connected:
                    
                 
                 
                 ;-------------------------------------------------------------------------
                 .include "command.inc"			; execute commands
                 
                 ;				Receive commands
                 ;-------------------------------------------------------------------------
                 ;00	get bootloader revision
                 ;01	get buffer size
                 ;02	get target signature
                 ;03	get user flash size
                 ;04	program flash
                 ;05	start application
                 ;06	check crc
                 ;07	verify flash
                 ;-------------------------------------------------------------------------
                 main_ok:
00fe92 d0d5      	    rcall putack
                 
                 main_waitcommand:
                 
                 	waitforcommand:
                      	 
00fe93 1730      	cp RL0, RL1
00fe94 f018      	brlo waitforcommand_fadeleds_off
                +
                +        .if Led_Port < 0x20
00fe95 985b     +cbi Led_Port , Led_Red_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       ClearPortBit Led_Port,Led_Red_Bit
                +
                +        .if Led_Port < 0x20
00fe96 9a5a     +sbi Led_Port , Led_Yellow_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       SetPortBit Led_Port,Led_Yellow_Bit
00fe97 c001      	  rjmp waitforcommand_fadeleds_cont
                     waitforcommand_fadeleds_off:
                       //ClearPortBit Led_Port,Led_Red_Bit
                +
                +        .if Led_Port < 0x20
00fe98 985a     +cbi Led_Port , Led_Yellow_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       ClearPortBit Led_Port,Led_Yellow_Bit
                 	waitforcommand_fadeleds_cont:
                 
00fe99 e048      	ldi RTemp,8
00fe9a 0f34      	add RL0,RTemp
00fe9b f419      	brne waitforcommand_fadeleds_delaycont
00fe9c 9513      	  inc RL2
00fe9d f409      	  brne waitforcommand_fadeleds_delaycont
00fe9e 9503      	    inc RL1
                 	waitforcommand_fadeleds_delaycont:
                 	 
                 
                 	  
00fe9f 994e               sbic FT245_StatusPin, FT245_RxfBit
00fea0 cff2      	 rjmp waitforcommand
                 
00fea1 d0a7      	rcall	getchar
00fea2 3060      	cpi a0,00 //Exit condition
00fea3 f411      	brne waitforcommand_cont
00fea4 d0c5      	    rcall putnack
00fea5 cf9c           	rjmp BootLoaderStart
                 	waitforcommand_cont:
00fea6 356a      	cpi a0,'Z' 
00fea7 f411      	brne waitforcommand_cont1
00fea8 d0bf      	    rcall putack
00fea9 cf98           	rjmp bootloaderstart
                 	waitforcommand_cont1:
00feaa 3463          cpi a0,COMMAND	
00feab f739      	brne	main_waitcommand			; loop until COMMAND char
                 
                 main_waitcommandvalue:
                 	
                 	waitforcommandvalue:
                      	 
00feac 1730      	cp RL0, RL1
00fead f018      	brlo waitforcommandvalue_fadeleds_off
                +
                +        .if Led_Port < 0x20
00feae 985b     +cbi Led_Port , Led_Red_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       ClearPortBit Led_Port,Led_Red_Bit
                +
                +        .if Led_Port < 0x20
00feaf 9a5a     +sbi Led_Port , Led_Yellow_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       SetPortBit Led_Port,Led_Yellow_Bit
00feb0 c002      	  rjmp waitforcommandvalue_fadeleds_cont
                     waitforcommandvalue_fadeleds_off:
                +
                +        .if Led_Port < 0x20
00feb1 9a5b     +sbi Led_Port , Led_Red_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       SetPortBit Led_Port,Led_Red_Bit
                +
                +        .if Led_Port < 0x20
00feb2 985a     +cbi Led_Port , Led_Yellow_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       ClearPortBit Led_Port,Led_Yellow_Bit
                 	waitforcommandvalue_fadeleds_cont:
                 
00feb3 e048      	ldi RTemp,8
00feb4 0f34      	add RL0,RTemp
00feb5 f419      	brne waitforcommandvalue_fadeleds_delaycont
00feb6 9513      	  inc RL2
00feb7 f409      	  brne waitforcommandvalue_fadeleds_delaycont
00feb8 9503      	    inc RL1
                 	waitforcommandvalue_fadeleds_delaycont:
                 	 
                 
                 	  
00feb9 994e               sbic FT245_StatusPin, FT245_RxfBit
00feba cff1      	 rjmp waitforcommandvalue
                 	
                 	
                 	
                 	
00febb d08d      	rcall	getchar
                 
00febc 3060      	cpi a0,00 //Exit condition
00febd f411      	brne commandvalue_cont
00febe d0ab      	    rcall putnack
00febf cf82           	rjmp BootLoaderStart
                 	commandvalue_cont:
00fec0 356a      	cpi a0,'Z' 
00fec1 f411      	brne commandvalue_cont1
00fec2 d0a5      	    rcall putack
00fec3 cf7e           	rjmp bootloaderstart
                 	commandvalue_cont1:
                 
                 .if FLASHEND > 0x7FFF
00fec4 e050      	ldi	zx, 0
                 .endif
00fec5 01f1      	movw	zh:zl, zeroh:zerol      ; Z = 0x0000,
00fec6 94e8      	clt				; T = 0 (for program, verify)
00fec7 3065      	cpi	a0, 5
00fec8 f060      	brcs	SendMessage		; command 1 ... 4
00fec9 f409      	brne	NotProgram
00feca c041      	  rjmp program			; command 5
                 
                     NotProgram:
00fecb 3066      	cpi	a0, 6
00fecc f409      	brne	NotRead
00fecd c02c      	  rjmp ReadFlash			; command 6
                 	NotRead:
00fece 3067      	cpi	a0, 7
00fecf f409      	brne NotVerifyFlash	
00fed0 c022      	   rjmp VerifyFlash		; command 7
                     NotVerifyFlash:
                 
                 
                 main_error:
00fed1 d098      	rcall putnack
00fed2 cfc0      	rjmp	main_waitcommand
                 ;-------------------------------------------------------------------------
                 bootloader_exit:				; command 5
                 .if FlashEnd > 0x0FFF
00fed3 940c 0000 		jmp	Application
                 .else
                 .endif
                 
                 ;-------------------------------------------------------------------------
                 .include "message.inc"			; command 0 ... 3
                 
                 ;				Send Messages
                 ;-------------------------------------------------------------------------
                 ;input: a0 = number of message 0 .. 3
                 ;
                 SendMessage:
00fed5 956a         dec a0
                 .if FLASHEND > 0x7FFF				//Load address of first message
00fed6 e051      	ldi	zx, byte3(2*Messages)
00fed7 bf5b      	out	RAMPZ, zx
                 .endif
00fed8 eeee      	ldi	zl, low (2*Messages)
00fed9 effe      	ldi	zh, high(2*Messages)
00feda e0c0      	ldi	yl, 0
                 _sme1:
00fedb 0fec      	add	zl, yl			; add offset to next message
00fedc 1df2      	adc	zh, zerol
                +
                +.if FLASHEND > 0x7FFF
00fedd 91c6     +elpm yl , z
                +.else 
                +lpm yl , z
                 	XLPM	yl, z
00fede 5061      	subi	a0, 1			; count down until message found
00fedf f7d8      	brcc	_sme1
                 
00fee0 e36e      	ldi	a0, '>'		; first byte of message
                     
                 _sme2:
00fee1 d072      	rcall	putchar
                +
                +.if FLASHEND > 0x7FFF
00fee2 9167     +elpm a0 , z +
                +.else 
                +lpm a0 , z +
                 	XLPM	a0, z+
00fee3 50c1      	subi	yl, 1
00fee4 f7e0      	brcc	_sme2
                 	
                 
                 
00fee5 cfac      	rjmp	main_ok
                 ;-------------------------------------------------------------------------
                 ;-------------------------------------------------------------------------
                 
                 .include "verify.inc"			; command 7
                 
                 ;		 		Verify User Flash
                 ;-------------------------------------------------------------------------
                 ;
                 _ver1:
                 .if FLASHEND > 0x7FFF
00fee6 bf5b      	out	RAMPZ, zx
00fee7 9006      	elpm	r0, z
00fee8 9631      	adiw	zh:zl, 1
00fee9 1d52      	adc	zx, zerol		; 24 bit addition
                 .else
                 .endif
                 .ifndef FirstBootStart
                 .endif
00feea 1206      	cpse	r0, a0
00feeb 9468      	set
                     
00feec f026      	brts _ver2
                +
                +        .if Led_Port < 0x20
00feed 985b     +cbi Led_Port , Led_Red_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                 	  ClearPortBit Led_Port,Led_Red_Bit
                +
                +        .if Led_Port < 0x20
00feee 9a5a     +sbi Led_Port , Led_Yellow_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       SetPortBit Led_Port,Led_Yellow_Bit
00feef 940c fef3 	  jmp VerifyFlash
                 	_ver2:
                +
                +        .if Led_Port < 0x20
00fef1 9a5b     +sbi Led_Port , Led_Red_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       SetPortBit Led_Port,Led_Red_Bit
                +
                +        .if Led_Port < 0x20
00fef2 985a     +cbi Led_Port , Led_Yellow_Bit
                +		.else 
                +ReadPort Led_Port , RTemp
                       ClearPortBit Led_Port,Led_Yellow_Bit
                 
                 
                 VerifyFlash:
00fef3 d055      	rcall	getchar
00fef4 f789      	brne	_ver1			; not COMMAND ?
00fef5 d053      	rcall	getchar
00fef6 5860      	subi	a0, ESC_SHIFT
00fef7 f771      	brne	_ver1			; COMMMAND + not COMMAND = End
00fef8 f2c6      	brts	main_error		; error, Flash not equal
00fef9 cf98      	rjmp	main_ok
                 ;-------------------------------------------------------------------------
                 
                 ;-------------------------------------------------------------------------
                 .include "readflash.inc"
                 
                  * ReadFlash.inc
                  *
                  *  Created: 06.05.2014 14:41:40
                  *   Author: Tom
                  */ 
                 
                 
                 
                  readflash:
                    
                 
                 
00fefa d04e         rcall getchar
00fefb 2ff6         mov ZH,a0
                 
00fefc d04c         rcall getchar
00fefd 2fe6         mov ZL,a0
                 
                 
00fefe d04a      		rcall getchar
00feff 2f96         mov RLoopCounterH,a0
00ff00 d048         		rcall getchar
00ff01 2f86         mov RLoopCounterL,a0
                 
                 
                 
                 	readflashloop:
                 
                 		.if FLASHEND > 0x7FFF
00ff02 bf5b      			out	RAMPZ, zx
00ff03 9166      			elpm	a0, z
00ff04 9631      			adiw	zh:zl, 1
00ff05 1d52      			adc	zx, zerol		; 24 bit addition
                 		.else
                 		.endif
                 
00ff06 d04d      		rcall putchar
                 
00ff07 9701      		sbiw RLoopCounterH:RLoopCounterL,1
00ff08 f7c9          brne readflashloop
                 
                 		
                 .include "progmega.inc"		; mega with bootstart fuse set
00ff09 cf88      
                 ;		 		Program User Flash
                 ;-------------------------------------------------------------------------
                 program_continue:
00ff0a ea69      	ldi	a0, CONTINUE			;Send CONTINUE char
00ff0b d048      	rcall	putchar
                 program:
00ff0c 9468      	set							;Set T flag, indicates exit allowed
00ff0d e0a0      	ldi	xl, low (ProgBuff)
00ff0e e0b1      	ldi	xh, high(ProgBuff)
00ff0f e0d5      	ldi	yh, high(ProgBuffEnd)
                 ;------------------------------ Receive data into buffer -----------------
                 pogram_receivechar:
00ff10 d038      	rcall	getchar				;Receive character
00ff11 f431      	brne	program_storebyte	;Branch if not the COMMAND char
00ff12 d036      	rcall	getchar
                 	
00ff13 5860      	subi	a0, ESC_SHIFT
00ff14 f419      	brne	program_storebyte	; command,80 = end mark, branch if last char have not been ESC_SHIFT/80
00ff15 f09e      	brts	program_exit		; Exit programmer code if T flag is set
00ff16 9468      	set							; Set T flag, indicates exit allowed
00ff17 c006      	rjmp	program_prog			
                 program_storebyte:
00ff18 d03b      	rcall putchar
00ff19 94e8      	clt							;Clear T flag, indicates exit not allowed
00ff1a 936d      	st	x+, a0					;Store received byte in ram
00ff1b 30a0      	cpi	xl, low (ProgBuffEnd)	;Check if buffer is full
00ff1c 07bd      	cpc	xh, yh
00ff1d f791      	brne	pogram_receivechar	;Receive next char if buffer is not full
                 ;-------------------------------------------------------------------------
                 program_prog:
00ff1e e0a0      	ldi	xl, low (ProgBuff)
00ff1f e0b1      	ldi	xh, high(ProgBuff)
                 program_progpages:
00ff20 d00a      	rcall	prog_page				; CY = 1: o.k
00ff21 f440      	brcc	program_error_exit		; exit to  main_error if page programming has returned a error
                 	//ldi R24,'X'
                 	//FT245_SendByte R24
00ff22 50e0      	subi	zl, low (-2*PageSize)
00ff23 4fff      	sbci	zh, high(-2*PageSize)	; point to next page
                 .if FLASHEND > 0x7FFF
00ff24 4f5f      	sbci    zx, byte3(-2*BufferSize)
                 .endif
00ff25 30a0      	cpi	xl, low (ProgBuffEnd)
00ff26 07bd      	cpc	xh, yh
00ff27 f7c1      	brne	program_progpages		; until buffer end
00ff28 f70e      	brtc	program_continue		;Continue if T flag is not set
                 ;-------------------------------------------------------------------------
                 program_exit:
00ff29 cf68      	rjmp	main_ok
                 program_error_exit:
00ff2a cfa6        rjmp main_error
                 ;-------------------------------------------------------------------------
                 ;			Program page in Flash
                 ;-------------------------------------------------------------------------
                 ;use:	r0, r1, a0, xl, xh, zl, zh
                 ;
                 ;input:  X  = buffer to RAM
                 ;        Z  = page to program
                 ;output: CY = 0: error, attempt to overwrite itself
                 ;
                 .equ    PAGEMASK	= (PAGESIZE * 2 - 1) & ~1
                 
                 prog_page:
                 ;------------------------------ Avoid self destruction ! -----------------
00ff2b 30e0      	cpi	zl, low (2*BootStart)
00ff2c ef6c      	ldi	a0, high(2*BootStart)
00ff2d 07f6      	cpc	zh, a0                  	; below bootloader ?
                 .if FLASHEND > 0x7FFF
00ff2e e061      	ldi     a0, byte3(2*BootStart)
00ff2f 0756      	cpc     zx, a0
                 .endif
00ff30 f4b8      	brcc	_prp3				; CY = 0: error
                 ;------------------------------ Fill page buffer -------------------------
00ff31 900d      _prp1:	ld	r0, x+
00ff32 901d      	ld	r1, x+
00ff33 e061      	ldi	a0, 1<<SPMEN
00ff34 d00b      	rcall	do_spm
00ff35 9632      	adiw	zh:zl, 2
00ff36 2f6e      	mov	a0, zl
00ff37 7f6e      	andi	a0, low(PAGEMASK)
00ff38 f7c1      	brne	_prp1
                 ;------------------------------ Erase page -------------------------------
00ff39 50e0      	subi	zl, low (2*PAGESIZE)
00ff3a 40f1      	sbci	zh, high(2*PAGESIZE)
00ff3b e063      	ldi	a0, 1<<PGERS^1<<SPMEN		; erase page command
00ff3c d003      	rcall	do_spm
                 ;------------------------------ Program page -----------------------------
00ff3d e065      	ldi	a0, 1<<PGWRT^1<<SPMEN		; write page command
00ff3e d001      	rcall	do_spm
00ff3f e161      	ldi	a0, 1<<RWWSRE^1<<SPMEN
                 do_spm:
                +
                +.if SPMCSR > 0x3F
                +sts SPMCSR , a0
00ff40 bf67     +.else 
                +out SPMCSR , a0
                 	xout	SPMCSR, a0
                 .if FLASHEND > 0x7FFF
00ff41 bf5b      	out     RAMPZ, zx               ; 3 byte Z pointer
                +
                +.if SPMCSR > 0x3F
                +sts SPMCSR , a0
00ff42 bf67     +.else 
                +out SPMCSR , a0
                 	xout    SPMCSR, a0
                 .endif
00ff43 95e8      	spm
                 _prp2:
                +
                +.if SPMCSR > 0x3F
                +lds a0 , SPMCSR
00ff44 b767     +.else 
                +in a0 , SPMCSR
                 	xin	a0, SPMCSR
00ff45 fd60      	sbrc	a0, SPMEN
00ff46 cffd      	rjmp	_prp2
00ff47 9408      	sec					; CY = 1: successful
                 _prp3:
00ff48 9508      	ret
                 ;-------------------------------------------------------------------------
                 
                 ;-------------------------------------------------------------------------
                 .include "ft245.inc"			; UART subroutines
                 
                  * FT245.inc
                  *
                  *  Created: 01.05.2014 13:30:05
                  *   Author: Tom
                  */ 
                 
                  getchar:
                 
                 		
                 
                 
00ff49 994e           sbic FT245_StatusPin, FT245_RxfBit	;Check if there is data to read
00ff4a cffe      	 rjmp getchar
                 
                +
                +
00ff4b 985d     +cbi FT245_StatusPort , FT245_RdBit
00ff4c 0000     +nop
00ff4d 0000     +nop
00ff4e 0000     +nop
00ff4f 0000     +nop
00ff50 b166     +in a0 , FT245_DataPin
00ff51 9a5d     +sbi FT245_StatusPort , FT245_RdBit
                 	 FT245_ReadByte a0
                 
00ff52 3463      	 cpi a0, COMMAND					;check if a0 contains the COMMAND char. Ugly, but taken from org code
00ff53 9508      ret
                 
                 putchar:
                 
                 		
                 
                 
00ff54 994f      	sbic FT245_StatusPin, FT245_TxeBit	;Check if data can be written
00ff55 cffe      	rjmp putchar
                 
                +
                +
                +FT245_WaitForWriteLoop :
00ff56 994f     +sbic FT245_StatusPin , FT245_TxeBit
00ff57 cffe     +rjmp FT245_WaitForWriteLoop
                +FT245_WaitForWrite
                +
                +
00ff58 ef4f     +ldi Rtemp , 0xff
                +
                +  .if FT245_DataDDR < 0x40
00ff59 b947     +out FT245_DataDDR , RTemp
                +  .else 
                +sts FT245_DataDDR , RTemp
                +WritePort FT245_DataDDR , RTemp
                +WritePortValue FT245_DataDDR , 0xff
                +FT245_SetOutput
                +
                +
00ff5a 0000     +nop
00ff5b 0000     +nop
00ff5c 9a5c     +sbi FT245_StatusPort , FT245_WrBit
00ff5d 0000     +nop
00ff5e 0000     +nop
00ff5f 0000     +nop
00ff60 b968     +out FT245_DataPort , a0
00ff61 0000     +nop
00ff62 0000     +nop
00ff63 0000     +nop
00ff64 985c     +cbi FT245_StatusPort , FT245_WrBit
                +FT245_WriteByte a0
                +
                +
                +
00ff65 e040     +ldi Rtemp , 0x00
                +
                +  .if FT245_DataDDR < 0x40
00ff66 b947     +out FT245_DataDDR , RTemp
                +  .else 
                +sts FT245_DataDDR , RTemp
                +WritePort FT245_DataDDR , RTemp
                +WritePortValue FT245_DataDDR , 0x00
                +FT245_SetInput
                 	FT245_SendByte a0
                 
00ff67 9508      ret
                 
                 putack:
00ff68 e461        ldi a0,'A'
00ff69 cfea        rjmp putchar
                 
                 putnack:
00ff6a e46e        ldi a0,'N'
00ff6b cfe8        rjmp putchar
                 ;-------------------------------------------------------------------------
                 fadeleds:
                 	;RL0 PWM counter
                 	;RL1 Fade counter
                 	;RL2 Delay
                 
                 
                 
00ff6c 9508      ret
                 
                 
                 
                 
                 Password:
00ff6d 654c
00ff6e 7364
00ff6f 7274
00ff70 7069
00ff71 6f43
00ff72 746e
00ff73 6f72
00ff74 6c6c
00ff75 7265
00ff76 0000      	.db	"LedstripController", 0, 0		
                 .list
                 Messages:
                 	.db \
00ff77 0203      	3, high(Version), low(Version), \
00ff78 0301      	3, high(2*BufferSize), low(2*BufferSize), \
00ff79 0004
00ff7a 1e04      	4, SIGNATURE_000, SIGNATURE_001, SIGNATURE_002, \
00ff7b 0597
00ff7c 0104
00ff7d 00fc      	4, byte3(UserFlash), byte2(UserFlash), byte1(UserFlash)
                 ;-------------------------------------------------------------------------
                 
                 //is this required?
                 	.org	Flashend
00ffff 9508      	ret
                 ;-------------------------------------------------------------------------
                 ;-------------------------------------------------------------------------
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega1284P" register use summary:
r0 :   6 r1 :   1 r2 :   4 r3 :   1 r4 :   0 r5 :   0 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 r13:   0 r14:   0 r15:   0 
r16:   9 r17:   9 r18:   7 r19:  13 r20:  28 r21:  10 r22:  49 r23:   0 
r24:   2 r25:   2 r26:   4 r27:   4 r28:   4 r29:   3 r30:  12 r31:  11 
x  :   3 y  :   0 z  :   5 
Registers used: 21 out of 35 (60.0%)

"ATmega1284P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   3 add   :   5 adiw  :   3 and   :   0 
andi  :   2 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   4 brcs  :   1 break :   0 breq  :   3 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   4 brlt  :   0 brmi  :   0 
brne  :  31 brpl  :   0 brsh  :   0 brtc  :   1 brts  :   3 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :  19 cbr   :   0 
clc   :   0 clh   :   0 cli   :   1 cln   :   0 clr   :   3 cls   :   0 
clt   :   2 clv   :   0 clz   :   0 com   :   0 cp    :   5 cpc   :   4 
cpi   :  14 cpse  :   1 dec   :   7 elpm  :   5 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :   4 inc   :   8 
jmp   :   2 ld    :   2 ldd   :   0 ldi   :  43 lds   :   1 lpm   :   0 
lsl   :   0 lsr   :   0 mov   :   5 movw  :   1 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :  36 or    :   0 ori   :   1 out   :  17 
pop   :   0 push  :   0 rcall :  27 ret   :   5 reti  :   0 rjmp  :  35 
rol   :   0 ror   :   0 sbc   :   0 sbci  :   3 sbi   :  20 sbic  :  10 
sbis  :   1 sbiw  :   1 sbr   :   0 sbrc  :   1 sbrs  :   0 sec   :   1 
seh   :   0 sei   :   0 sen   :   0 ser   :   0 ses   :   0 set   :   4 
sev   :   0 sez   :   0 sleep :   0 spm   :   2 st    :   1 std   :   0 
sts   :   2 sub   :   0 subi  :   6 swap  :   0 tst   :   1 wdr   :   1 

Instructions used: 49 out of 114 (43.0%)

"ATmega1284P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x01fc00 0x020000    732     34    766  131072   0.6%
[.dseg] 0x000100 0x000500      0   1024   1024   16384   6.3%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
